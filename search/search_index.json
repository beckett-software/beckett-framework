{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udcab Beckett framework","text":"<p>The Efficient Framework for Building Type-Safe Python Web Servers and React TypeScript Websites</p> <p></p> <p>Welcome to Beckett, a solution for rapidly constructing type-safe Python web servers and React TypeScript websites while ensuring consistent typing interfaces across both languages.</p> <p>Beckett seamlessly combines the power of Flask, a popular Python web framework, with a robust React TypeScript web server, providing a comprehensive full stack framework. Unlike traditional project set ups, Beckett eliminates the need for an intermediary domain language because it tightly couples the Typed API interface, resulting in a more streamlined development process.</p> <p>At its core, Beckett features a sophisticated types manager that automatically synchronizes Python Type hints and TypeScript interfaces. This means that as you make changes to your code, Beckett diligently keeps the API interface definitions in both languages in perfect harmony. Gone are the worries about compatibility issues when deploying changes\u2014the Beckett framework ensures seamless deployments.</p> <p>While Beckett is strongly opinionated, favoring specific design choices, it significantly enhances productivity by providing a cohesive development experience and reducing the time spent on manual synchronization.</p> <p></p>"},{"location":"#harnessing-powerful-tools-becketts-foundation","title":"Harnessing Powerful Tools: Beckett's Foundation","text":"<p>Beckett harnesses the power of industry-leding tools by seamlessly integratin a Flask web server and a React TypeScript frontend into a unified framework.</p> <p>Both TypeScript and Python hold their positions as two of the most widely used programming languages globally. As a result, they are frequently combined in various projects. However, setting up a smooth and efficient development environment that harmoniously integrates these languages can be a cumbersome and time-consuming process, often leading to a subpar developer experience.</p> <p>Thankfully, Beckett steps in to solve this challenge by tightly coupling TypeScript and Python, uniting them as a cohesive framework.</p>"},{"location":"#unleasing-their-individual-potential","title":"Unleasing Their Individual Potential","text":"<p>Beckett recognizes that each language excels in different domains and allows you to leverage their strengths as needed. You can continue to write Flask views just as you would in a typical Flask application, benefiting from the extensive ecosystem of Python libraries that seamlessly integrate with Flask.</p> <p>Simultaneously, you can harness the power of React TypeScript for your frontend development, providing an optimal solution. Write your React components and TypeScript code as you would in any other React application, and effortlessly incorporate any JavaScript library you desire by using <code>yarn add</code> to meet the specific requirements of your project.</p> <p>Beckett empowers you to continue utilizing these languages individually, allowing you to take advantage of their distinctive capabilities while enjoying the enhanced development experience offered by the unified framework.</p> <p>Wanna learn more? Start with the features to learn what Beckett brings to the table.</p>"},{"location":"configuration/","title":"\ud83d\udd27 Configuration","text":"<p>Beckett is heavily convention-based, yet you can configure quite a bit of it based on what your project set up needs.</p>"},{"location":"configuration/#settings","title":"Settings","text":"<p>All settings should be set as environment variables.</p>"},{"location":"configuration/#environment","title":"<code>ENVIRONMENT</code>","text":"<p>Default: <code>development</code></p> <p>When this variable is set to <code>development</code> in order to enable the Beckett hot-reloader and auto generation features.</p>"},{"location":"configuration/#beckett_metafile_path","title":"<code>BECKETT_METAFILE_PATH</code>","text":"<p>Defaut: <code>{pwd}/metafile.json</code></p> <p>The file tracks the manifest of React pages registered in the app, and enables hot-reloading in development. In production is provides a link between the Flask view function and the React page (because it will be generated with a hash that the Flask view function doesn't know about).</p>"},{"location":"configuration/#beckett_react_page_template","title":"<code>BECKETT_REACT_PAGE_TEMPLATE</code>","text":"<p>Default: <code>{pwd}/template/beckett_page.template</code></p> <p>This is the template used when generating new React pages.</p>"},{"location":"features/","title":"\ud83d\udcc4 Features","text":""},{"location":"features/#strongly-linked-types","title":"Strongly-linked types","text":"<p>When we built Beckett we decided that if we're going to bundle the languages together, why not link them strongly and find extra benefits?</p> <p>The first major feature we built was strongly-linked types.</p> <p>Beckett takes your Python Typehints and auto-generates TypeScript interfaces to maintain type integrity across both languages. It does this automatically for any API endpoints in the Flask web server using the Beckett decorators.</p> src/views/people.py<pre><code>import attrs\nfrom src.app import app\nfrom src.beckett.blueprint import BeckettBlueprint\nfrom src.beckett.types import APIResponse\nblueprint = BeckettBlueprint(\"people\", __name__, url_prefix=\"/people\")\n@attrs.define\nclass GetPeopleResponse(APIResponse):\nname: str\n@blueprint.api_get(\"/get\")\ndef get_people() -&gt; GetPeopleResponse:\n\"\"\"\n    This is an example API GET route.\n    \"\"\"\nreturn GetPeopleResponse(name=\"Paul\")\napp.register_blueprint(blueprint)\n</code></pre> <p>When the Beckett flask server is running, this will autogenerate the following TypeScript interface:</p> js/api/types.ts<pre><code>/*\nTHIS FILE IS AUTO-GENERATED, DO NOT ALTER MANUALLY.\n*/\n// prettier-ignore\nexport interface PeopleGetPeopleResponse {\n\"__type__\": string\n\"__http_status_code__\": number\n\"name\": string\n}\n...\n</code></pre> <p>Beckett automatically adds additional parameters to any <code>APIResponse</code> object it such as <code>__type__</code> and <code>__http_status_code__</code>. Beckett's TypeScript API Client uses these fields to introspect the API response and handle errors gracefully for you.</p> <p>Under the hood, we use attrs and cattrs to take the types in the classes we define and transform them into their TypeScript equivalents.</p>"},{"location":"features/#react-pages","title":"React pages","text":"<p>Beckett will auto-generate any new React page when you register a new Beckett page in the Flask service, when you are in development mode. Beckett's is built such that a Flask route (defined through the URL of a Flask view function) can be linked directly to a React page on the frontend.</p> src/views/people.py<pre><code>import attrs\nfrom src.app import app\nfrom src.beckett.blueprint import BeckettBlueprint\nbeckett = BeckettBlueprint(\"people\", __name__, url_prefix=\"/people\")\n# Hiding other endpoints for clarity\n...\n@attrs.define\nclass ExamplePageProps:\nhello: str\n@beckett.route(\"/\")\n@beckett.page()\ndef example_page() -&gt; ExamplePageProps:\nreturn ExamplePageProps(hello=\"world\")\napp.register_blueprint(beckett)\n</code></pre> <p>When the Beckett Flask server is running in development mode it will recognise a new endpoint has been registered, and it makes a new React page linked to the Flask view. This is all handled by applying the <code>@beckett.page()</code> decorator.</p> <p>The generated page will start something like this:</p> src/js/template/people/example_page.tsx<pre><code>import React from 'react'\nimport PageProps from './example_page.type'\nimport {Container, Row} from 'react-bootstrap'\nconst Page: React.FunctionComponent&lt;PageProps&gt; = (props) =&gt; {\nreturn (\n&lt;Container&gt;\n&lt;Row className=\"mb-4 border-bottom\"&gt;\n&lt;h1&gt;Hello, React!&lt;/h1&gt;\n&lt;p&gt;\nhere are my props: &lt;code&gt;{props}&lt;/code&gt;\n&lt;/p&gt;\n&lt;/Row&gt;\n&lt;/Container&gt;\n)\n}\nexport default Page\n</code></pre> <p>The template can be customised by setting the <code>BECKETT_REACT_PAGE_TEMPLATE</code> environment variable to a path.</p> <p>Once this has been generated you are free to go and develop the frontend using any React library you want.</p>"},{"location":"features/#props-for-react-pages","title":"Props for React pages","text":"<p>As well as the base page, <code>beckett.page()</code> also generates a <code>PageProps</code> interface. The response returned by the Flask view are injected as props into this page for you automatically. The generated file for the example above looks something like this:</p> src/js/template/people/example_page.type.ts<pre><code>// This file is generated by @beckett.page()\n// prettier-ignore\nexport default interface PageProps {\n\"hello\": string\n}\n</code></pre> <p>This file will update automatically as you make changes to the Flask view response class and the server is in development mode.</p>"},{"location":"features/#api-client","title":"API Client","text":"<p>TODO</p>"},{"location":"features/#refresh-api-queries","title":"Refresh API queries","text":"<p>TODO</p>"},{"location":"features/#run-it-all-together-at-once","title":"Run it all together at once","text":"<p>Instead of maintaining multiple terminals running two different servers, Beckett provides a single development command to run both the Flask service and React server in development mode. Both are these run in \"hot reload\" - any code changes will restart each server so changes happen immediately.</p> <pre><code>make dev\n</code></pre>"},{"location":"install/","title":"\ud83c\udfd7\ufe0f Install","text":""},{"location":"install/#early-days","title":"Early days","text":"<p>Currently the project is still being set up, but you can use it by forking the project and running the following commands:</p> <pre><code>make build\nmake dev\n</code></pre> <p>This will install everything you need and start the development server.</p>"},{"location":"types_conversion/","title":"\ud83c\udfb9 Types conversion","text":"<p>Remember! Beckett doesn't just convert one way.</p> <p>API requests going into the Beckett Flask service will be checked for type consistency.</p> <p>Beckett Framework uses Beckett types to manage types translation.</p>"},{"location":"types_conversion/#conversion-chart","title":"Conversion chart","text":"<p>We translate Python TypeHints into these TypeScript types, and vice versa:</p> Python TypeScript <code>str</code> <code>string</code> <code>int</code> <code>number</code> <code>float</code> <code>number</code> <code>decimal.Decimal</code> <code>number</code> <code>dict</code> <code>Record&lt;string, any&gt;</code>"},{"location":"types_conversion/#nested-types","title":"Nested types","text":"<p>Nested <code>attrs</code> classes are converted infinitely:</p> example.py<pre><code>@attrs.define\nclass Subclass:\nhello: str\n@attrs.define\nclass ExamplePageProps:\ntest: Subclass\n</code></pre> <p>Which generates:</p> types.ts<pre><code>// prettier-ignore\nexport interface Subclass {\n\"hello\": string\n}\n// prettier-ignore\nexport default interface PageProps {\n\"test\": Subclass\n}\n</code></pre>"}]}